# Selection Sort(선택 정렬)

해당 순서에 원소를 넣을 위치는 이미 정해져 있고, 어떤 원소를 넣을지 선택하는 알고리즘이다.

위치에 들어올 원소를 찾는 방식으로 정렬한다.

O(n\*\*2)의 시간복잡도를 가지는 기초적인 정렬 알고리즘 코드는 단순하지만 높은 시간복잡도를 가진다.

# 동작방식

1. 주어진 리스트 중에 최소값을 찾는다.
2. 그 값을 맨 앞에 위치한 값과 교체한다.
3. 맨 처음 위치를 뺀 나머지 리스트를 같은 방법으로 교체한다.

반대로 최대값을 찾아 마지막 인덱스에 배치하는 방법도 가능하다.

# 슈도 코드

```
def selection_sort(array):
    n = len(array)
    for i in range(n):
        # 최솟값의 인덱스 찾기
        min_idx = min(array)의 index
        # 현재위치와 최솟값위치를 맞교환
        array[min_idx], array[i] = array[i], array[min_idx]
    return array
```

# 시간 복잡도

비교하는 것이 상수 시간에 이루어진다는 가정 아래, n개의 주어진 배열을 정렬하는데 O(n^2) 만큼의 시간이 걸린다. 최선, 평균, 최악의 경우 시간복잡도는 O(n^2) 으로 동일하다.

# 공간 복자도

주어진 배열 안에서 교환(swap)을 통해, 정렬이 수행되므로 O(n) 이다.

# 장점

Bubble sort와 마찬가지로 알고리즘이 단순하다.

정렬을 위한 비교 횟수는 많지만, Bubble Sort에 비해 실제로 교환하는 횟수는 적기 때문에 많은 교환이 일어나야 하는 자료상태에서 비교적 효율적이다.

Bubble Sort와 마찬가지로 정렬하고자 하는 배열 안에서 교환하는 방식이므로, 다른 메모리 공간을 필요로 하지 않는다. => 제자리 정렬(in-place sorting)

# 단점

시간복잡도가 O(n^2)으로, 비효율적이다.

불안정 정렬(Unstable Sort) 이다.
